name: Process Novel Folder

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  process-novel:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: pip install chardet

      - name: Process novel folder
        run: |
          import os
          import zipfile
          import json
          import re
          from chardet import detect

          NOVEL_DIR = "novel"
          OUTPUT_DIR = "output"

          # Common encodings to try (in order of preference)
          COMMON_ENCODINGS = [
              'utf-8',
              'gb18030',
              'big5',
              'gbk',
              'gb2312',
              'utf-16',
              'iso-8859-1'
          ]

          os.makedirs(OUTPUT_DIR, exist_ok=True)

          def detect_encoding(file_path):
              with open(file_path, 'rb') as f:
                  rawdata = f.read(1024)
                  result = detect(rawdata)
                  if result['confidence'] > 0.9:
                      return result['encoding']
              
              for encoding in COMMON_ENCODINGS:
                  try:
                      with open(file_path, 'r', encoding=encoding) as f:
                          f.read(1024)
                      return encoding
                  except:
                      continue
              
              return 'utf-8'

          def read_file_with_fallback(file_path):
              encoding = detect_encoding(file_path)
              try:
                  with open(file_path, 'r', encoding=encoding) as f:
                      return f.read()
              except Exception as e:
                  pass
              
              for encoding in COMMON_ENCODINGS:
                  try:
                      with open(file_path, 'r', encoding=encoding) as f:
                          return f.read()
                  except:
                      continue
              
              return f"ERROR: Could not decode file with any encoding"

          def parse_novel_content(content):
              # Initialize the novel structure
              novel = {
                  "metadata": {},
                  "chapters": []
              }
              
              # Extract metadata
              name_author_match = re.search(r'『(.+?)/作者:(.+?)』', content)
              if name_author_match:
                  novel["metadata"]["name"] = name_author_match.group(1).strip()
                  novel["metadata"]["author"] = name_author_match.group(2).strip()
              
              status_match = re.search(r'『狀態:更新到:(.+?)』', content)
              if status_match:
                  novel["metadata"]["status"] = status_match.group(1).strip()
              
              intro_match = re.search(r'『內容簡介:(.+?)』', content, re.DOTALL)
              if intro_match:
                  novel["metadata"]["introduction"] = intro_match.group(1).strip()
              
              # Remove all metadata and footer before chapter content
              content = re.sub(r'^.*?------章節內容開始-------\n', '', content, flags=re.DOTALL)
              
              # Extract chapters - improved pattern to handle full chapter content
              chapter_pattern = re.compile(r'^(第\d+章[^\n]+)\n([\s\S]+?)(?=^第\d+章|\Z)', re.MULTILINE)
              chapters = chapter_pattern.findall(content)
              
              for chapter in chapters:
                  chapter_title = chapter[0].strip()
                  chapter_num = re.search(r'第(\d+)章', chapter_title).group(1)
                  chapter_content = chapter[1].strip()
                  
                  # Clean up chapter content (remove extra spaces and empty lines)
                  chapter_content = '\n'.join([line.strip() for line in chapter_content.split('\n') if line.strip()])
                  
                  novel["chapters"].append({
                      "chapter_number": chapter_num,
                      "chapter_title": chapter_title.replace(f'第{chapter_num}章', '').strip(),
                      "content": chapter_content
                  })
              
              return novel

          def save_novel_structure(novel_name, novel_data, output_base_dir):
              # Create folder for this novel
              novel_dir = os.path.join(output_base_dir, novel_name)
              os.makedirs(novel_dir, exist_ok=True)
              
              # Save metadata
              with open(os.path.join(novel_dir, "metadata.json"), 'w', encoding='utf-8') as f:
                  json.dump(novel_data["metadata"], f, ensure_ascii=False, indent=4)
              
              # Save each chapter as separate JSON
              chapters_dir = os.path.join(novel_dir, "chapters")
              os.makedirs(chapters_dir, exist_ok=True)
              
              for chapter in novel_data["chapters"]:
                  chapter_filename = f"chapter_{chapter['chapter_number']}.json"
                  with open(os.path.join(chapters_dir, chapter_filename), 'w', encoding='utf-8') as f:
                      json.dump(chapter, f, ensure_ascii=False, indent=4)
              
              return len(novel_data["chapters"])

          def unzip_and_process(zip_path, output_base_dir):
              with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                  temp_dir = os.path.splitext(zip_path)[0]
                  zip_ref.extractall(temp_dir)
                  
                  results = {}
                  for root, _, files in os.walk(temp_dir):
                      for file in files:
                          file_path = os.path.join(root, file)
                          if file.lower().endswith('.txt'):
                              content = read_file_with_fallback(file_path)
                              novel_data = parse_novel_content(content)
                              novel_name = os.path.splitext(file)[0]
                              chapter_count = save_novel_structure(novel_name, novel_data, output_base_dir)
                              results[novel_name] = {
                                  "metadata_file": f"{novel_name}/metadata.json",
                                  "chapter_count": chapter_count
                              }
                          else:
                              results[file] = "Non-text file (not processed)"
                  return results

          def process_novel_folder():
              zip_files = [f for f in os.listdir(NOVEL_DIR) if f.endswith(".zip")]
              
              summary = {}
              
              for file in zip_files:
                  zip_path = os.path.join(NOVEL_DIR, file)
                  print(f"\nProcessing {zip_path}...")
                  
                  results = unzip_and_process(zip_path, OUTPUT_DIR)
                  summary[file] = results
                  
                  # Print processing summary
                  print(f"\nProcessing summary for {file}:")
                  print("=" * 60)
                  for novel_name, data in results.items():
                      if isinstance(data, dict):
                          print(f"{novel_name}:")
                          print(f"  - Metadata: {data['metadata_file']}")
                          print(f"  - Chapters: {data['chapter_count']} chapter files")
                      else:
                          print(f"{novel_name}: {data}")
                  print("=" * 60)
                  print(f"✅ Processed {file}")

              # Save summary
              with open(os.path.join(OUTPUT_DIR, "processing_summary.json"), 'w', encoding='utf-8') as f:
                  json.dump(summary, f, ensure_ascii=False, indent=4)
              
              print("\nOverall processing complete!")
              print(f"Summary saved to: {os.path.join(OUTPUT_DIR, 'processing_summary.json')}")

          process_novel_folder()
        shell: python

      - name: Commit and push changes
        if: github.ref == 'refs/heads/main'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add output/
          git commit -m "Update novel files with folder structure" || echo "No changes to commit"
          git push
