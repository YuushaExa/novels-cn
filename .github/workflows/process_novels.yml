name: Process Novel Folder

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  process-novel:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: pip install chardet

      - name: Process novel folder
        run: |
          import os
          import zipfile
          import json
          import re
          from chardet import detect

          NOVEL_DIR = "novel"
          OUTPUT_DIR = "output"

          # Common encodings to try (in order of preference)
          COMMON_ENCODINGS = [
              'utf-8',
              'gb18030',
              'big5',
              'gbk',
              'gb2312',
              'utf-16',
              'iso-8859-1'
          ]

          os.makedirs(OUTPUT_DIR, exist_ok=True)

          def detect_encoding(file_path):
              with open(file_path, 'rb') as f:
                  rawdata = f.read(1024)
                  result = detect(rawdata)
                  if result['confidence'] > 0.9:
                      return result['encoding']
              
              for encoding in COMMON_ENCODINGS:
                  try:
                      with open(file_path, 'r', encoding=encoding) as f:
                          f.read(1024)
                      return encoding
                  except:
                      continue
              
              return 'utf-8'

          def read_file_with_fallback(file_path):
              encoding = detect_encoding(file_path)
              try:
                  with open(file_path, 'r', encoding=encoding) as f:
                      return f.read()
              except Exception as e:
                  pass
              
              for encoding in COMMON_ENCODINGS:
                  try:
                      with open(file_path, 'r', encoding=encoding) as f:
                          return f.read()
                  except:
                      continue
              
              return f"ERROR: Could not decode file with any encoding"

          def parse_novel_content(content):
              # Initialize the novel structure
              novel = {
                  "metadata": {},
                  "chapters": []
              }
              
              # Extract metadata
              name_author_match = re.search(r'『(.+?)/作者:(.+?)』', content)
              if name_author_match:
                  novel["metadata"]["name"] = name_author_match.group(1).strip()
                  novel["metadata"]["author"] = name_author_match.group(2).strip()
              
              status_match = re.search(r'『狀態:更新到:(.+?)』', content)
              if status_match:
                  novel["metadata"]["status"] = status_match.group(1).strip()
              
              intro_match = re.search(r'『內容簡介:(.+?)』', content, re.DOTALL)
              if intro_match:
                  novel["metadata"]["introduction"] = intro_match.group(1).strip()
              
              # Remove all metadata and footer before chapter content
              content = re.sub(r'^.*?------章節內容開始-------\n', '', content, flags=re.DOTALL)
              
              # Extract chapters - improved pattern to handle full chapter content
              chapter_pattern = re.compile(r'^(第\d+章[^\n]+)\n([\s\S]+?)(?=^第\d+章|\Z)', re.MULTILINE)
              chapters = chapter_pattern.findall(content)
              
              for chapter in chapters:
                  chapter_title = chapter[0].strip()
                  chapter_num = re.search(r'第(\d+)章', chapter_title).group(1)
                  chapter_content = chapter[1].strip()
                  
                  # Clean up chapter content (remove extra spaces and empty lines)
                  chapter_content = '\n'.join([line.strip() for line in chapter_content.split('\n') if line.strip()])
                  
                  novel["chapters"].append({
                      "chapter_number": chapter_num,
                      "chapter_title": chapter_title.replace(f'第{chapter_num}章', '').strip(),
                      "content": chapter_content
                  })
              
              return novel

          def unzip_and_process(zip_path):
              with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                  temp_dir = os.path.splitext(zip_path)[0]
                  zip_ref.extractall(temp_dir)
                  
                  novels = {}
                  for root, _, files in os.walk(temp_dir):
                      for file in files:
                          file_path = os.path.join(root, file)
                          if file.lower().endswith('.txt'):
                              content = read_file_with_fallback(file_path)
                              novel_data = parse_novel_content(content)
                              novels[file] = novel_data
                          else:
                              novels[file] = "Non-text file (not processed)"
                  return novels

          def process_novel_folder():
              zip_files = [f for f in os.listdir(NOVEL_DIR) if f.endswith(".zip")]
                            
              for file in zip_files:
                  zip_path = os.path.join(NOVEL_DIR, file)
                  print(f"\nProcessing {zip_path}...")
                  
                  novels = unzip_and_process(zip_path)
                  
                  json_filename = os.path.splitext(file)[0] + ".json"
                  output_path = os.path.join(OUTPUT_DIR, json_filename)
                  with open(output_path, 'w', encoding='utf-8') as f:
                      json.dump(novels, f, ensure_ascii=False, indent=4)
                  
                  # Create a sample JSON with first item and first chapter
                  sample_json = {}
                  for filename, novel_data in novels.items():
                      if isinstance(novel_data, dict):
                          sample_novel = {
                              "metadata": novel_data["metadata"],
                              "chapters": novel_data["chapters"][:1] if novel_data["chapters"] else []
                          }
                          sample_json[filename] = sample_novel
                      else:
                          sample_json[filename] = novel_data
                      break
                  
                  print(f"\nSample JSON structure from {json_filename}:")
                  print("=" * 60)
                  print(json.dumps(sample_json, ensure_ascii=False, indent=2))
                  print("=" * 60)
                  
                  total_chapters = sum(len(novel["chapters"]) for novel in novels.values() if isinstance(novel, dict))
                  print(f"✅ Saved {json_filename} (total chapters: {total_chapters})")

          process_novel_folder()
        shell: python

      - name: Commit and push changes
        if: github.ref == 'refs/heads/main'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add output/
          git commit -m "Update individual JSON files with structured novel data" || echo "No changes to commit"
          git push
